# Behaving Properly - Pure Functions

# 行为得体——纯函数



上一章我们重点介绍了函数式编程中的关键要素——函数，并详细介绍了箭头函数及相关概念，如注入（`injection`）、回调（`callback`）、填充（`polyfilling`）、打桩（`stubbing`）等。本章将重新审视并应用其中一些观点，并主要介绍以下内容：

- 引入“纯度”的概念，以及为何要关注纯函数、非纯函数；
- 考察“引用透明度”的概念；
- 认识到副作用潜藏的问题；
- 展示纯函数的一些优点；
- 阐述非纯函数背后的逻辑；
- 设法最小化非纯函数的数量；
- 聚焦纯函数和非纯函数的测试方法。

---



## 4.1. 纯函数 Pure functions

纯函数的行为方式与数学上的函数相同，并具备诸多好处。当一个函数满足以下两个条件，即为 **纯函数**：

- **给定相同的参数，该函数总是计算并返回相同的结果**：无论调用多少次或在什么条件下调用，该命题都成立；其结果不依赖于任何 **外部** 的信息或状态，否则这些信息或状态可能会在程序执行期间发生变化并导致返回值的改变。函数结果也不能依赖于 `I/O` 结果、随机数、以及其他一些外部变量或不能直接控制的值；
- **在计算其结果时，该函数不会引起任何可观察到的“副作用”**：这包括输出到 `I/O` 终端、对象的变化、函数外的程序状态更改等等；

简单来说，纯函数不依赖（也不修改）其作用域之外的任何内容，并且始终为相同的输入参数返回相同的结果。

在该语境下常用的另一个术语概念是 **幂等性**，但二者并不完全相同。幂等函数可以根据需要多次调用，并且总是产生相同的结果；但这并不意味着该函数没有副作用。幂等性通常出现在 `RESTful` 风格的服务上下文中。这里举个简单的例子来区分纯度（`purity`）和幂等性（`idempotency`）。调用 `PUT` 请求会导致数据库记录被更新（副作用），但如果反复调用，元素将不会被进一步修改，因此数据库的全局状态也不会进一步改变。

借用一个软件设计原则（单一职责）来提醒自己：一个函数应该 **做一件事就只做这件事，除此之外什么都不做**。如果一个函数实现了其他逻辑或具备一些隐藏功能，那么该函数对其状态的依赖将无法正确预测结果，加大开发者的处理难度。

下面就来深入研究一下这些控制因素。



### 4.1.1. 引用透明度 Referential transparency

### 4.1.2. 副作用 Side effects

### 4.1.3. 纯函数的好处 Advantages of pure functions

## 4.2. 非纯函数 Impure functions

### 4.2.1. 避开非纯函数 Avoiding impure functions

#### 1 避免使用状态 Avoiding the usage of state

#### 2 注入非纯函数 Injecting impure functions

### 4.2.2. 纯函数判定 Is your function pure?

## 4.3. 测试纯函数及非纯函数 Testing – pure versus impure

### 4.3.1. 纯函数测试 Testing pure functions

### 4.3.2. 纯化处理后的函数测试 Testing purified functions

### 4.3.3. 非纯函数测试 Testing impure functions

## 4.4. 小结 Summary

## 4.5. 思考题 Questions