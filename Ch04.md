# Behaving Properly - Pure Functions

# 行为得体——纯函数



上一章我们重点介绍了函数式编程中的关键要素——函数，并详细介绍了箭头函数及相关概念，如注入（`injection`）、回调（`callback`）、填充（`polyfilling`）、打桩（`stubbing`）等。本章将重新审视并应用其中一些观点，并主要介绍以下内容：

- 引入“纯度”的概念，以及为何要关注纯函数、非纯函数；
- 考察“引用透明度”的概念；
- 认识到副作用隐含的问题；
- 介绍纯函数的一些优点；
- 阐述非纯函数背后的逻辑；
- 设法最小化非纯函数的数量；
- 探讨纯函数和非纯函数的测试方法。

---



## 4.1. 纯函数 Pure functions

纯函数的行为方式与数学上的函数相同，并具备诸多好处。当一个函数满足以下两个条件，即为 **纯函数**：

- **给定相同的参数，该函数总是计算并返回相同的结果**：无论调用多少次或在什么条件下调用，该命题都成立；其结果不依赖于任何 **外部** 的信息或状态，否则这些信息或状态可能会在程序执行期间发生变化并导致返回值的改变。函数结果也不能依赖于 `I/O` 结果、随机数、以及其他一些外部变量或不能直接控制的值；
- **在计算其结果时，该函数不会引起任何可观察到的“副作用”**：这包括输出到 `I/O` 终端、对象的改变、函数外的程序状态更改等等；

简单来说，纯函数不依赖（也不修改）其作用域之外的任何内容，并且始终为相同的输入参数返回相同的结果。

在该语境下常用的另一个术语概念是 **幂等性**，但二者并不完全相同。幂等函数可以根据需要多次调用，并且总是产生相同的结果；但这并不意味着该函数没有副作用。幂等性通常出现在 `RESTful` 风格的服务上下文中。这里举个简单的例子来区分纯度（`purity`）和幂等性（`idempotency`）。调用 `PUT` 请求会导致数据库记录被更新（副作用），但如果反复调用，元素将不会被进一步修改，因此数据库的全局状态也不会进一步改变。

借用一个软件设计原则（单一职责）来提醒自己：一个函数应该 **做一件事就只做这件事，除此之外什么都不做**。如果一个函数实现了其他逻辑或具备一些隐藏功能，那么该函数对其状态的依赖将无法正确预测结果，加大开发者的处理难度。

下面就来深入研究一下这些控制因素。



### 4.1.1. 引用透明 Referential transparency



数学里的 **引用透明** 是一种特性（`property`），可以用表达式的值替换表达式，而不改变原来的任何结果。

> **知识拓展**
>
> 引用透明的对立面，是 **引用不透明**。这样的函数在调用时，即便使用相同的参数也无法保证总是产生相同的结果。

例如，考虑一个做优化处理的编译器在执行 **常量折叠** 时发生的变化。原始代码如下：

```js
const x = 1 + 2 * 3;
```

编译器可能会将 `2 * 3` 视为常量，优化为：

```js
const x = 1 + 6;
```

更理想的情况，甚至可以完全避免求和：

```js
const x = 7;
```

编译器正是利用了所有数学表达式和函数按照定义都具备的引用透明的特性来节省执行时间的。此外，如果编译器无法预测给定表达式的结果，则无法完成任何形式的代码优化，只能在运行时进行计算。

> **拓展**
>
> 在 λ 演算中，如果将目标函数表达式的值替换为函数的计算值，则该操作称为 **β 化简**。请注意，这里只能使用引用透明的函数。

所有的算术表达式（包含数学运算符和函数）都是引用透明的：`22 * 9` 总是可以被 `198` 替换；涉及 `I/O` 的表达式是不透明的，因为在具体执行之前无法得知它们的结果。同理，涉及日期和时间相关的函数或随机数表达式也是不透明的。

至于自定义的函数，很容易写出一些不满足 **引用透明** 条件的来。事实上，一个函数甚至都不需要返回一个值，尽管 `JavaScript` 解释器会默认返回一个 `undefined` 的值。

> **拓展**
>
> 一些语言还区分了函数（`function`）和过程（`procedure`）。函数要返回一个值，过程不返回任何东西；但 `JavaScript` 不是。还有一些编程语言提供了确保函数引用透明的方法。

如果要分类的话，函数可以分为以下三类：

- **纯函数**：返回值至取决于函数参数、没有任何副作用的函数；
- **副作用函数**：不返回任何值、但会产生某些副作用的函数（实际上也会返回一个 `undefined` 值，但不是讨论重点）；
- **带副作用的函数**：返回值不仅仅取决于参数，还含有一些副作用。

在函数式编程中，尤为强调第一类——引用透明的纯函数。此时编译器不仅可以推断程序行为（从而能够优化生成的代码），程序员也可以更轻松地推断程序及其组件之间的联系。这反过来又可以帮助证明算法的正确性，或通过函数等效替换来进一步优化代码。



### 4.1.2. 副作用 Side effects

何为 **副作用**？我们可以将其定义为在执行某些计算或过程期间，程序所发生的状态变化；或者与外部元素所发生的交互，如用户、Web 服务、另一台计算机等等。

对于这个定义的适用范围可能存在误解。在日常谈话中一谈到副作用，更像是在谈论 **附带伤害**——某个特定行为的一些意料之外的结果；然而，计算机领域的副作用，则包含了函数外部的所有可能的影响或变化。如果一个函数要执行 `console.log()` 来显示结果，则会被视为副作用，即便它正是该函数本应实现的首要功能。

本节主要介绍以下内容：

- `JavaScript` 中常见的副作用；
- 全局及内部状态引发的问题；
- 函数参数不固定时的情况；
- 一些总是很棘手的函数；



#### 1 常见副作用 Usual side effects

编程中被视为副作用的东西可太多了。在 `JavaScript` 中，无论前端后端，您可能会看到以下常见的副作用：

- 改变全局变量；
- 改变作为参数传入的对象；
- 任何类型的输入输出操作，例如显示 `alert` 消息或将一些文本写入日志；
- 操作、更改文件系统；
- 更新数据库；
- 调用 `Web` 服务；
- 查询或修改 `DOM`；
- 触发任何外部进程；
- 仅仅是调用了另一个碰巧产生副作用的函数。这可以理解为不纯函数具有 **传染性**：调用不纯函数的函数会自动变为不纯函数！

有了这个定义，让我们来看看哪些因素会导致函数不纯（或引用不透明）。



#### 2 全局状态下的副作用 Global state

在上述所有要点中，产生副作用的最常见原因，是使用了与程序其他模块共享了全局状态的非局部变量。根据定义，纯函数总是在给定相同入参的情况下返回相同的出参值。如果一个函数引用了其内部状态之外的任何东西，则会自动变为不纯函数；这也为后续调试制造了障碍：要了解一个函数实现了什么功能，必须理解该状态如何获取到当前最新的值——这意味着必须理解在这之前的所有历史代码逻辑：这可不是个轻松活。

让我们编写一个函数，通过检查一个人是否至少出生于 18 年前，来判定他们是否是合法成年人。（诚然这不够精确，因为没有考虑出生日期和月份；但请多担待，这不是讨论的重点）。满足需求的函数 `isOldEnough()` 代码实现如下：

```js
let limitYear = 1999;

const isOldEnough = birthYear => birthYear <= limitYear;

console.log(isOldEnough(1960)); // true
console.log(isOldEnough(2001)); // false
```

函数 `isOldEnough()` 可以正确检测某人是否至少 18 岁，但这取决于一个外部变量（该变量仅适用于 2017 年）。除非您了解外部变量的含义、并知晓它是如何获取到值的，否则将无从了解该函数的作用。而且测试也会很困难：必须记得创建全局变量 `limitYear`，否则测试将无法进行。即使该函数有效，但代码实现并不是最佳的。

这种情况也有例外：考察以下函数 `circleArea()`，用于计算给定半径的圆面积。该函数是否为纯函数呢？

```js
const PI = 3.14159265358979;
const circleArea = r => PI * Math.pow(r, 2); // 或 PI * r ** 2
```

即便函数访问了外部状态，但 `PI` 是一个常量（因此无法修改）的事实，允许我们在没有功能性修改的前提下，在 `circleArea` 内部将其替换为一个值，因此可被视为一个纯函数。该函数将始终为相同的参数返回相同的值，从而符合纯度定义。

> **提示**
>
> 即使换用 `Math.PI` 而非代码中定义的常量（顺便说一下，用 `Math.PI` 是更好的解决方案），参数仍然是相同的；常量不会改变，所以仍然是纯函数。

了解了全局状态引起的副作用，再来看看函数内部状态的问题。



#### 3 内部状态下的副作用 Inner state

副作用的概念还可以推广到保存了本地状态、以备后续调用的内部变量。此时外部状态没有变化，但由于函数的返回值所隐含的后续状态差异，仍有可能引入副作用。不妨假设一个舍入函数 `roundFix()` ，为了让上下舍入的累计误差趋近于零，函数会在下一次运算时执行与本次相反的舍入操作。该函数将不得不对先前舍入的总效应做一个汇总来决定下一步操作，可能的代码实现如下：

```js
const roundFix = (function() {
    let accum = 0;
    return n => {
        // 实际上下或向下舍入取决于 accum 的符号
        let nRounded = accum > 0 ? Math.ceil(n) : Math.floor(n);
        console.log("accum", accum.toFixed(5), " result", nRounded);
        accum += n - nRounded;
        return nRounded;
    };
})();
```

其中——

- 本例中的 `console.log()` 只是便于罗列当前的累计误差及函数的返回值，看看是执行了向上还是向下舍入，实际不会包含在函数中；
- 为了获取一个隐藏的内部变量，这里用到了 `IIFE` 模式；
- 第 5 行求 `nRounded` 的值也可以写作 `Math[accum > 0 ? "ceil": "floor"](n)`——考察 `accum` 的正负来决定调用 `ceil` 或 `floor`，然后用 `Object["method"]` 的写法调用 `Object.method()`。本例的写法其实更清楚，这里只是给出另一种写法，仅供参考。

只用两个值测试该函数（发现了吗）结果表明：对于给定的输入，最终结果并不总是相同。控制台打印部分展示了某个值是如何上下舍入的：

```js
roundFix(3.14159); // accum  0.00000    result 3
roundFix(2.71828); // accum  0.14159    result 3
roundFix(2.71828); // accum -0.14013    result 2
roundFix(3.14159); // accum  0.57815    result 4
roundFix(2.71828); // accum -0.28026    result 2
roundFix(2.71828); // accum  0.43802    result 3
roundFix(2.71828); // accum  0.15630    result 3
```

第一轮，`accum` 为零，`3.14159` 向下舍入，`accum` 变为 `0.14159`，符合预期；
第二轮，`accum` 为正，向上收入，故 `2.71828` 被收至 `3`，`accum` 变为负数；
第三轮，`accum` 为负，相同的值 `2.71828` 被舍入为 `2`——相同的输入，却得到了不同的值。

可见，由于函数的结果取决于其 **内部状态**，同样的参数在累计误差的作用下，可以向上或向下舍入而得到不同的结果。

> **提示**
>
> 像这样使用内部状态，也是许多 `FP` 开发者认为使用对象可能不太好的原因。在面向对象编程中，开发者习惯于存储信息到某个属性，以备后续调用；然而，这种做法被认为是不纯的（`impure`），因为重复的方法调用也可能返回不同的值，尽管传入了相同的参数。

除了全局及内部状态下的副作用，还有其他情况也可能存在副作用，比如改变传入的参数值的情况。一起来看看吧。



#### 4 改变参数导致的副作用 Argument mutation

不纯函数会修改参数值——这一情况也要引起重视。在 `JavaScript` 中，参数是按 **值** 传递的，但数组和对象除外，它们是按 **引用** 传递的。这意味着对函数形参的任何修改都会引起实参中原对象或数组的实际修改。`JavaScript` 中的几个突变方法（mutator methods）可以根据定义修改目标对象，进一步掩盖了这一副作用。例如，想要一个可以找出字符串数组中最大元素的函数（若为数字数组，可以简单地使用 `Math.max()`），假设代码实现如下：

```js
const maxStrings = a => a.sort().pop();

let countries = ["Argentina", "Uruguay", "Brasil", "Paraguay"];
console.log(maxStrings(countries)); // "Uruguay"
```

该函数确实能得出正确结果（若考虑外语对排序的影响，请参考上一章的相关章节)，但它存在一个缺陷。考察原始数组：

```js
console.log(countries); // ["Argentina", "Brasil", "Paraguay"]
```

糟糕——原数组被修改了；这就是副作用。如果您要再次调用 `maxStrings(countries)`，那么它不会返回与之前相同的结果，而是得到另一个值；该函数显然不是纯函数。面对这种情况，一个快速解决方案是使用数组的副本（如借助扩展运算符，更多处理手法将在第十章重点论述）：

```js
const maxStrings2 = a => [...a].sort().pop();

let countries = ["Argentina", "Uruguay", "Brasil", "Paraguay"];
console.log(maxStrings2(countries)); // "Uruguay"
console.log(countries); // ["Argentina", "Uruguay", "Brasil", "Paraguay"]
```

至此，我们讨论了修改函数自身参数引起的副作用，再来考察最后一种情况：函数被迫为不纯函数。



#### 5 一些棘手的函数 Troublesome functions

最后，一些函数本身也会带来问题。例如，随机函数 `Math.random()` 本身就是不纯的：它并不总是返回相同的值，否则就与设计初衷相违背。该函数每调用一次，就会修改一个全局 `seed` 值，以便计算下一个随机数。

> **拓展**
>
> 随机数实际上是由内部函数计算得到的，因此根本不是随机的（如果提前知道使用的公式和种子的初值的话），更名为 `pseudorandom` 可能更准确。

例如，考虑如下函数，用于生成随机字母（`A` 到 `Z`）：

```js
const getRandomLetter = () => {
    const min = "A".charCodeAt();
    const max = "Z".charCodeAt();
    return String.fromCharCode(
        Math.floor(Math.random() * (1 + max - min)) + min
    );
};
```

该函数不接收任何参数，但却能在每次调用时会产生不同的结果，这一事实清楚地表明，该函数是不纯的。

> **提示**
>
> 关于 `getRandomLetter()` 函数的详细解释，参考 [MDN 文档之 random](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random)；更多 `.charCodeAt()` 介绍，详见 [MDN 文档之 String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String)。

非纯特性可以通过调用函数来传播。如果一个函数用到了一个不纯的函数，它自身就会立即变得不纯。例如，想用函数 `getRandomLetter()` 来生成随机文件名，并带有可选的给定扩展名。假设代码实现如下：

```js
const getRandomFileName = (fileExtension = "") => {
    const NAME_LENGTH = 12;
    let namePart = new Array(NAME_LENGTH);
    for (let i = 0; i < NAME_LENGTH; i++) {
        namePart[i] = getRandomLetter();
    }
    return namePart.join("") + fileExtension;
};
```

> **提示**
>
> 第五章《声明式编程——一种更好的风格》中，还会利用 `map()` 函数的特性，介绍一种更偏函数式风格的方法来初始化数组 `namePart`。

由于用到了非纯函数 `getRandomLetter()`，原函数 `getRandomFileName()` 也变得不纯了，尽管函数运行符合预期，能正确生成完全随机的文件名： 

```js
console.log(getRandomFileName(".pdf"));  // "SVHSSKHXPQKG.pdf"
console.log(getRandomFileName(".pdf"));  // "DCHKTMNWFHYZ.pdf"
console.log(getRandomFileName(".pdf"));  // "GBTEFTVVHADO.pdf"
console.log(getRandomFileName(".pdf"));  // "ATCBVUOSXLXW.pdf"
console.log(getRandomFileName(".pdf"));  // "OIFADZKKNVAH.pdf"
```

记住这个函数，后续章节我们还将围绕它谈谈单元测试的问题，并在此基础上做一些改动来解决这个问题。

The concern about impurity also extends to functions that access the current time or date, because their results will depend on an outside condition (namely the time of day) that is part of the *global state* of the application. We could rewrite our isOldEnough() function to remove the dependency upon a global variable, but it wouldn't help much. An attempt could be as follows:

对杂质的关注也延伸到访问当前时间或日期的函数，因为它们的结果将取决于作为应用程序*全局状态*一部分的外部条件（即一天中的时间）。 我们可以重写我们的 isOldEnough() 函数来消除对全局变量的依赖，但这并没有多大帮助。 尝试如下

非纯特性也可以推广至当前时间或日期的访问，因为它们的结果取决于外部条件（即一天里的时间）——也是应用程序全局状态的一部分。我们也可以重写函数 `isOldEnough()` 来消除原函数对全局变量的依赖，但这并没有多大帮助。尝试改动代码如下：

```js
const isOldEnough2 = birthYear =>
  birthYear <= new Date().getFullYear() - 18;

console.log(isOldEnough2(1960)); // true
console.log(isOldEnough2(2001)); // false
```

此时解决了一个问题——新的 `isOldEnough2()` 函数现在更安全了。此外，只要不在元旦午夜前后使用它，函数就会始终返回相同的结果，因此，套用 19 世纪的 `Ivory Soap` 的口号，可以说该函数 **大约 99.44% 是纯的**；但是仍有不便：如何测试？万一编写的函数今天运行良好，明年偏就就会测试失败呢？所以还需要做一些工作来解决这个问题，后续会详讲。

还有其他几个同样不纯的函数，例如那些导致 `I/O` 的函数。如果函数从某个数据源（`Web` 服务、用户自己、文件或其他源）获取输入，显然返回的结果会有所不同。同时还应该考虑 `I/O` 搞错的可能，因此调用相同服务或读取相同文件的相同函数可能在某些时候由于不可抗力的因素而调用失败（也可以假设文件系统、数据库、套接字这些可能统统都不可用，此时调用指定的函数可能会产生某个错误，而不是意料中的常量、或不变的结果）。

即使是单纯输出结果、或通常不会在内部（至少以可见方式）更改任何内容的一般安全语句（如 `console.log()`），也会导致一些副作用。因为用户确实看到了更改：根据生成的输出结果。

凡此种种，是否意味着永远无法编写出一个程序，既能得到随机数、又能处理日期、还能允许 `I/O` 操作、并且还能同时使用纯函数呢？答案是否定的——但这确实意味着一些函数是不纯的，使用时必须考虑它们存在的不足；稍后会继续讨论。



### 4.1.3. 纯函数的好处 Advantages of pure functions

#### 1 执行顺序 Order of execution

#### 2 缓存函数值 Memoization

#### 3 自带文档描述 Self-documentation

#### 4 利于测试

## 4.2. 非纯函数 Impure functions

### 4.2.1. 避开非纯函数 Avoiding impure functions

#### 1 避免使用状态 Avoiding the usage of state

#### 2 注入非纯函数 Injecting impure functions

### 4.2.2. 纯函数判定 Is your function pure?

## 4.3. 测试纯函数及非纯函数 Testing – pure versus impure

### 4.3.1. 纯函数测试 Testing pure functions

### 4.3.2. 纯化处理后的函数测试 Testing purified functions

### 4.3.3. 非纯函数测试 Testing impure functions

## 4.4. 小结 Summary

## 4.5. 思考题 Questions