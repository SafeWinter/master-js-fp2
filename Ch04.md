# Behaving Properly - Pure Functions

# 行为得体——纯函数



上一章我们重点介绍了函数式编程中的关键要素——函数，并详细介绍了箭头函数及相关概念，如注入（`injection`）、回调（`callback`）、填充（`polyfilling`）、打桩（`stubbing`）等。本章将重新审视并应用其中一些观点，并主要介绍以下内容：

- 引入“纯度”的概念，以及为何要关注纯函数、非纯函数；
- 考察“引用透明度”的概念；
- 认识到副作用隐含的问题；
- 介绍纯函数的一些优点；
- 阐述非纯函数背后的逻辑；
- 设法最小化非纯函数的数量；
- 探讨纯函数和非纯函数的测试方法。

---



## 4.1. 纯函数 Pure functions

纯函数的行为方式与数学上的函数相同，并具备诸多好处。当一个函数满足以下两个条件，即为 **纯函数**：

- **给定相同的参数，该函数总是计算并返回相同的结果**：无论调用多少次或在什么条件下调用，该命题都成立；其结果不依赖于任何 **外部** 的信息或状态，否则这些信息或状态可能会在程序执行期间发生变化并导致返回值的改变。函数结果也不能依赖于 `I/O` 结果、随机数、以及其他一些外部变量或不能直接控制的值；
- **在计算其结果时，该函数不会引起任何可观察到的“副作用”**：这包括输出到 `I/O` 终端、对象的改变、函数外的程序状态更改等等；

简单来说，纯函数不依赖（也不修改）其作用域之外的任何内容，并且始终为相同的输入参数返回相同的结果。

在该语境下常用的另一个术语概念是 **幂等性**，但二者并不完全相同。幂等函数可以根据需要多次调用，并且总是产生相同的结果；但这并不意味着该函数没有副作用。幂等性通常出现在 `RESTful` 风格的服务上下文中。这里举个简单的例子来区分纯度（`purity`）和幂等性（`idempotency`）。调用 `PUT` 请求会导致数据库记录被更新（副作用），但如果反复调用，元素将不会被进一步修改，因此数据库的全局状态也不会进一步改变。

借用一个软件设计原则（单一职责）来提醒自己：一个函数应该 **做一件事就只做这件事，除此之外什么都不做**。如果一个函数实现了其他逻辑或具备一些隐藏功能，那么该函数对其状态的依赖将无法正确预测结果，加大开发者的处理难度。

下面就来深入研究一下这些控制因素。



### 4.1.1. 引用透明 Referential transparency



数学里的 **引用透明** 是一种特性（`property`），可以用表达式的值替换表达式，而不改变原来的任何结果。

> **知识拓展**
>
> 引用透明的对立面，是 **引用不透明**。这样的函数在调用时，即便使用相同的参数也无法保证总是产生相同的结果。

例如，考虑一个做优化处理的编译器在执行 **常量折叠** 时发生的变化。原始代码如下：

```js
const x = 1 + 2 * 3;
```

编译器可能会将 `2 * 3` 视为常量，优化为：

```js
const x = 1 + 6;
```

更理想的情况，甚至可以完全避免求和：

```js
const x = 7;
```

编译器正是利用了所有数学表达式和函数按照定义都具备的引用透明的特性来节省执行时间的。此外，如果编译器无法预测给定表达式的结果，则无法完成任何形式的代码优化，只能在运行时进行计算。

> **拓展**
>
> 在 λ 演算中，如果将目标函数表达式的值替换为函数的计算值，则该操作称为 **β 化简**。请注意，这里只能使用引用透明的函数。

所有的算术表达式（包含数学运算符和函数）都是引用透明的：`22 * 9` 总是可以被 `198` 替换；涉及 `I/O` 的表达式是不透明的，因为在具体执行之前无法得知它们的结果。同理，涉及日期和时间相关的函数或随机数表达式也是不透明的。

至于自定义的函数，很容易写出一些不满足 **引用透明** 条件的来。事实上，一个函数甚至都不需要返回一个值，尽管 `JavaScript` 解释器会默认返回一个 `undefined` 的值。

> **拓展**
>
> 一些语言还区分了函数（`function`）和过程（`procedure`）。函数要返回一个值，过程不返回任何东西；但 `JavaScript` 不是。还有一些编程语言提供了确保函数引用透明的方法。

如果要分类的话，函数可以分为以下三类：

- **纯函数**：返回值至取决于函数参数、没有任何副作用的函数；
- **副作用函数**：不返回任何值、但会产生某些副作用的函数（实际上也会返回一个 `undefined` 值，但不是讨论重点）；
- **带副作用的函数**：返回值不仅仅取决于参数，还含有一些副作用。

在函数式编程中，尤为强调第一类——引用透明的纯函数。此时编译器不仅可以推断程序行为（从而能够优化生成的代码），程序员也可以更轻松地推断程序及其组件之间的联系。这反过来又可以帮助证明算法的正确性，或通过函数等效替换来进一步优化代码。



### 4.1.2. 副作用 Side effects

### 4.1.3. 纯函数的好处 Advantages of pure functions

## 4.2. 非纯函数 Impure functions

### 4.2.1. 避开非纯函数 Avoiding impure functions

#### 1 避免使用状态 Avoiding the usage of state

#### 2 注入非纯函数 Injecting impure functions

### 4.2.2. 纯函数判定 Is your function pure?

## 4.3. 测试纯函数及非纯函数 Testing – pure versus impure

### 4.3.1. 纯函数测试 Testing pure functions

### 4.3.2. 纯化处理后的函数测试 Testing purified functions

### 4.3.3. 非纯函数测试 Testing impure functions

## 4.4. 小结 Summary

## 4.5. 思考题 Questions