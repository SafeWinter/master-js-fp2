# Starting Out with Functions - A Core Concept

# 第三章 从函数开始——一个核心概念

---

上一章我们用了一个案例来介绍函数式编程思想，本章来看看函数式编程的基础知识，并回顾一下函数的相关知识点。第一章提过，`JavaScript` 的两个重要特性：

1. 函数作一等对象；
2. 函数作闭包。

本章涉及要点：

- `JavaScript` 中的函数，包括如何定义（尤其是箭头函数）；
- 函数科里化，以及作一等对象的函数；
- 以函数式编程的方式使用函数的几种方法。

学完这些内容后，您将了解与函数相关的通用及特定概念。它们是函数式编程的核心。



## 3.1. 函数面面观 All about functions

首先简要回顾一下 `JavaScript` 中函数的相关知识，厘清函数与函数式编程之间的联系。在第一章的重点论述、以及第二章的多处介绍中，我们曾提到函数可以作为一等对象，进一步考察了它们在实际编码中的使用。本节重点关注以下三个方面：

- 关于 λ 算子的一些重要的基础概念——它们是函数式编程的理论基础；
- 箭头函数——是 `Lambda` 算子在 `JavaScript` 语言的最直接的诠释；
- 视函数为一等对象——函数式编程中的一个关键概念。



### 3.1.1. `Lambda` 表达式与函数 Of lambdas and functions

一个函数按 Lambda 演算的术语要求，可以表示为：

$\lambda x.2 * x$

其中字母 λ 后的变量相当于函数的参数，句点后的表达式，是可以替换作为参数传递的任意值的地方。稍后您将看到本例按 `JavaScript` 箭头函数的语法，可以写作：`x => 2 * x`，形式上十分类似。

> **提示：arguments 与 parameter**
>
> 分清参数 `arguments` 与参数 `parameter` 之间的区别，可以借助一些押韵的顺口溜来强化记忆：*Parameters are Potential, Arguments are Actual*（参数是潜在的，参数是实际的）。`parameter` 是要传递的潜在值的占位符，而 `arguments` 是实际传给函数的值。换句话说，定义函数时，您列出的参数是 `parameter`；而当调用它时，需要提供 `arguments`。

应用一个函数，是指如同平时写代码那样，使用括号向其提供实际的参数（`arguments`）。例如，$(\lambda x.2*x)(3)$ 的值为 6。这些 `Lambda` 函数在 `JavaScript` 下的等效形式是什么样的呢？这是个值得探讨的问题，因为定义函数的方法有好几种，并且它们在含义上并不完全相同。

> **拓展阅读**
>
> 有篇不错的文章介绍了函数及方法定义的多种不同方式，不妨了解一下，具体详见 *Leo Balter* 及 *Rick Waldron* 的文章：[The Many Faces of Functions in JavaScript](https://bocoup.com/blog/the-many-faces-of-functions-in-javascript)（`JavaScript` 中函数的多种表现形式）。

您能用多少种方式定义一个 `JavaScript` 函数呢？答案可能比您原以为的要多。至少可以写出以下几种：

1. 具名函数声明：`function first(...) {...};`
2. 匿名函数表达式：`var second = function(...) {...};`
3. 具名函数表达式：`var third = function someName(...) {...};`
4. `IIFE` 立即引用表达式：`var fourth = (function() { ...; return function(...) {...}; })();`
5. 构造函数：`var fifth = new Function(...);`
6. 箭头函数：`var sixth = (...) => {...};`

此外，你还也可以添加对象方法声明，因为它们也隐含了函数的成分。不过上述清单已经够用了。

那么，这些函数定义方法的区别在哪儿？为什么值得关注呢？让我们一个一个来考察：

> **提示**
>
> `JavaScript` 还可以定义生成器函数（`generator function`），形如 `function*(...) {...}`，返回一个生成器对象 `Generator`；以及定义异步函数（`async function`），其实质为 `generator` 与 `promise` 的结合。本节不使用这三种函数，更多详情参考 `MDN` 这两篇文档：
>
> - [MDN 文档之 function*](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function*);
> - [MDN 文档之 async function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)

1. 第一种定义，以关键字 `function` 开头的独立声明形式，应该是 `JavaScript` 中最常见的定义方式。这里定义了一个名为 `first` 的函数（即 `first.name=="first"`）由于变量提升效应，该函数将在其定义的作用域内可随处任意访问。关于变量提升效应，详见 [MDN 文档](https://developer.mozilla.org/en-US/docs/Glossary/Hoisting)，只需记住一点：该效应只作用于变量声明，而非变量初始化。

2. 第二种定义，将函数赋给一个变量，也能得到一个函数，只不过是个匿名函数（即没有命名）。然而不少 `JavaScript` 引擎是可以推断出函数名称的，例如设定本例中的 `second.name === "second"`。（观察下面的示例代码，函数名称没有赋给匿名函数）鉴于变量提升效应不提升变量赋值，该函数只能在赋值之后的代码位置方可访问；再者，您可能更倾向于使用 `const` 而非 `var` 来定义该变量，因为不太会（也不应该）改变该函数：

   ```js
   var second = function() {};
   console.log(second.name);
   // "second"
   
   var myArray = new Array(3);
   myArray[1] = function() {};
   console.log(myArray[1].name);
   // ""
   ```

   

3. 第三种定义，与第二种相同，只是此时的函数拥有其自己的名称：`third.name === "someName"`。

> **提示**
>
> 函数的名称与您调用的时机有关，在执行递归调用时更是如此。第九章《函数设计——递归》中还会详细论述这一点。如果只想要一个回调函数，您可以使用一个没有名称的函数；但要注意，在错误回溯中，当您试图了解代码报错时使用的列表类型，以及哪个函数调用了什么的时候，命名函数更容易被识别。

4. 第四种定义的 `IIFE` 立即引用表达式使用了闭包的知识。内部函数可以以完全私有、被封装的方式，访问在其外部函数中定义的变量或其他函数。回顾第一章闭包一节定义的计次函数，可以编写如下代码：

   ```js
   var myCounter = (function(initialValue = 0) {
       let count = initialValue;
       return function() {
           count++;
           return count;
       };
   })(77);
   
   myCounter(); // 78
   myCounter(); // 79
   myCounter(); // 80
   ```

   仔细钻研这段代码，外部函数接收一个参数 77 作为 `count` 的初值（默认为 0）。由于闭包的缘故，内部函数可以访问到 `count`。从各方面看，返回的函数都是一个通用函数——唯一的区别在于它访问了私有元素。 这也是模块型设计模式（`module pattern`）的基础。

5. 第五类定义由于不安全，还是不用的好。这种方式首先传入参数列表，然后是一个字符串形式的函数体，用到了与调用 `eval()` 相同的方式创建函数。这可能招致很多危险的黑客攻击，所以不要用这类定义。为满足读者的好奇心，这里给出一个根据第一章展开运算符小节重写后的 `sum3` 函数示例：

   ```js
   var sum3 = new Function("x", "y", "z", "var t = x + y + z; return t;");
   sum3(4, 6, 7); // 17
   ```

   > **拓展**
   >
   > 这类定义不仅不安全，还有其他坑——不会在其创建函数的上下文中创建闭包，因此这些私有变量都是全局的。详见 [MDN 文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function)。切记，用这种方式创建函数是下下策。
   >
   > 续：MDN 原文为：使用 `Function` 构造函数创建的函数不会为其创建上下文（`creation context`）创建闭包； 它们总是在全局范围内创建。 运行它们时，它们将只能访问自己的局部变量和全局变量，而不能访问创建 `Function` 构造函数的作用域内的变量。 这不同于将 `eval()` 与函数表达式的代码一起使用。
   >
   > 以下是文档提供的示例代码：
   >
   > ```js
   > var x = 10;
   > 
   > function createFunction1() {
   >     var x = 20;
   >     return new Function('return x;'); // this |x| refers global |x|
   > }
   > 
   > function createFunction2() {
   >     var x = 20;
   >     function f() {
   >         return x; // this |x| refers local |x| above
   >     }
   >     return f;
   > }
   > 
   > var f1 = createFunction1();
   > console.log(f1());          // 10
   > var f2 = createFunction2();
   > console.log(f2());          // 20
   > ```

6. 最后一种定义，使用带 `=>` 符号的箭头函数定义，是代码最为紧凑的一种定义方式，也是我们将尽可能尝试使用的方式。

至此，我们已经考察了定义函数的若干种方式，接下来重点关注箭头函数，这也是本书力荐的一种代码风格。



### 3.1.2. 箭头函数——更流行的方式 Arrow functions – the modern way

尽管箭头函数与其他函数的工作原理非常类似，但与普通函数相比还是有一些重要的区别。箭头函数可以不带 `return` 语句隐式地返回某个值、同时也没有绑定 `this` 的操作、不存在 `arguments` 对象。一起来看看这三个区别吧。

> **提示**
>
> 箭头函数还有其它不同之处：不能作构造函数使用、没有 `prototype` 属性、由于不支持 `yield` 也不能用作生成器（`generator`）。详情参考 [MDN 文档页](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions#No_binding_of_this)。

In this section, we'll go into several JavaScript function-related topics, including:

本节我们将讨论以下几个与 `JavaScript` 函数相关的话题：

1. 不同函数返回值的处理；
2. `this` 取值问题的处理；
3. 参数个数不固定时的处理；
4. **科里化**（`currying`）的相关知识（一个后续章节将会多次用到的重要概念）。



#### 1. 返回值 Returning values

按照 `Lambda` 演算的编码风格，函数由一个结果构成。简化起见，新引入的箭头函数也提供了相应的语法支持。当写作 `(x, y, z) =>` 并后跟一个表达式时，就隐式包含了一个 `return` 语句。例如下面的两个函数就与前文演示的 `sum3()` 函数效果相同：

```js
const f1 = (x, y, z) => x + y + z;

const f2 = (x, y, z) => {
    return x + y + z;
};
```

如若返回的是一个对象，则必须添加小括号，否则 `JavaScript` 会误以为后面跟的是代码。

> **小贴士**
>
> 注意箭头函数的编码风格：定义一个单参数函数时，可以忽略两边的小括号。为连贯起见，笔者更倾向于保留括号。然而本书用到的格式化工具 `Prettier` 则倾向于默认不保留。读者可根据个人喜好随意选择。

需要注意的最后一点：未避免您认为这是一个不大可能的情况，请移步至本章 **思考题** 小节，查看一个非常常见的情况！



#### 2. `this` 值的处理 Handling the this value

`JavaScript` 的一个经典问题是 `this` 的处理，其具体取值往往并不按您想象的来。`ES2015` 借助箭头函数解决了 `this` 的指向问题。来看下面这个例子：超时函数被调用时，`this` 会指向全局变量（`window`）而非新的对象，因此控制台输出的是 `undefined`：

```js
function ShowItself1(identity) {
    this.identity = identity;
    setTimeout(function() {
        console.log(this.identity);
    }, 1000);
}

var x = new ShowItself1("Functional");
// 一秒后显示 undefined
```

解决这个问题，旧版 `JavaScript` 有两个经典方案，以及新版的箭头函数方案：

- 旧版方案一：利用闭包的特性，定义一个本地变量（通常命名为 `that` 或 `self`），这样就能获取到想要的值，而非 `undefined`；
- 旧版方案二：使用 `bind()` 函数，将超时函数绑定到正确的值上；
- 箭头函数版：这是更流行的写法，无需其他改动就能获取到正确的值（直接指向对象）。

> **提示**
>
> 本书同样会使用 `bind()`，详见 3.1.1 小节《表达式与函数 Of lambdas and functions》。

三种方案的代码实现如下：第一个 `timeout` 函数使用了闭包，第二个用到了函数绑定，第三个用到了箭头函数：

```js
function ShowItself2(identity) {
    this.identity = identity;
    let that = this;
    setTimeout(function() {
        console.log(that.identity);
    }, 1000);

    setTimeout(
        function() {
            console.log(this.identity);
        }.bind(this),
        2000
    );

    setTimeout(() => {
        console.log(this.identity);
    }, 3000);
}

var x = new ShowItself2("JavaScript");
// 一秒后显示 "JavaScript"
// 再过一秒同样显示 "JavaScript"
// 又过一秒还是显示 "JavaScript"
```

三种方法都能正确运行，具体选哪一个视个人喜好决定。



#### 3. `arguments` 的处理 Working with arguments

前两章曾提到展开运算符（`...`）的使用。然而我们后续用得最多的场景是对 `arguments` 对象的处理（第六章详述）。先来重温上一章的 `once()` 函数：

```js
const once = func => {
  let done = false;
  return (...args) => {
    if (!done) {
      done = true;
      func(...args);
    }
  };
};
```

为什么在写了 `return (...args) =>` 这句后，第 6 行又接着调用了 `func(...args)` 呢？旧版 `JavaScript` 是怎么处理这个问题的呢？这需要用到 `arguments` 对象（**不是** 数组！）来访问实际传入的参数。

> **小贴士**
>
> 更多 `arguments` 的介绍，详见 [MDN 官方文档](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments)。

在 `JavaScript` 5 及以前，若要得到一个能处理任意数量参数的函数，代码需要像这样写：

```js
function somethingElse() {
    // get arguments and do something
}

function listArguments() {
    console.log(arguments);
    var myArray = Array.prototype.slice.call(arguments);
    console.log(myArray);
    somethingElse.apply(null, myArray);
}

listArguments(22, 9, 60);
// (3) [22, 9, 60, callee: function, Symbol(Symbol.iterator): function]
// (3) [22, 9, 60]
```

第一句日志输出的是一个对象；第二句才出一个普通数组。还要注意调用 `somethingElse()` 函数的复杂写法，这里用到了 `apply()`（签名为 `func.apply(thisArg, [argsArray])`）。

那么新版 `JavaScript` 会怎么处理呢？新版的代码要简短得多，这也是您后续将多次看到展开运算符的身影的原因：

```js
function listArguments2(...args) {
    console.log(args);
    somethingElse(...args);
}

listArguments2(12, 4, 56);
// (3) [12, 4, 56]
```

查看上述代码您需要牢记以下三点：

- 写下 `listArguments2(...args)` 表明新函数将接收若干个参数（也可能没有参数）；
- 无需手动构造一个参数数组，控制台的结果可以看到 `args` 就是一个数组；
- `somethingElse(...args)` 的写法较 `apply()` 的写法更清晰明了。

顺便说一下，新版 `JS` 中的 `arguments` 对象同样是有效的，若要根据 `arguments` 创建新函数，可以使用以下两种变通方案来替换 `Array.prototype.slice.call`：

- 使用 `Array.from`：`var myArray=Array.from(arguments)`；
- 使用 `[] + ...`：`let myArray=[...arguments]`。这也是展开运算符的另一种用法。

When we get to the topic of higher-order functions, writing functions that deal with other functions, with a possibly unknown number of parameters, will be commonplace.

这在我们后续讲高阶函数时，需要用函数来处理其它参数数量不固定的函数时，尤为常见。

`JavaScript` 为这类问题提供了简便写法，因此必须尽快习惯这类写法，很划算。



#### 4. 单参数还是多参数？ One argument or many?

编写一个返回值为函数的函数也是可以的（第六章详述）。例如，按 Lambda 算子的演算要求，所用的函数没有多个参数的情况，只有一个参数；这时可以通过一项称为函数科里化（`currying`）的处理来满足需求（这么做用意何在呢？先按下不表）

> **提示**
>
> 科里化（`Currying`）得名于这一概念的提出者 ***Haskell Curry***。值得一提的是，有一门函数式编程语言也被冠名为 `Haskell`，这也是对他所做贡献的双重认可。

几个例子，之前演示过的三数相加的函数可以写作：

```js
const altSum3 = x => y => z => x + y + z;
```

为什么这里重命名了呢？简单讲，该函数与之前定义的函数 `sum3()` 不同。尽管如此，它也有异曲同工之妙，只是侧重点不同罢了。来看看它的具体使用：例如对数字 1、2 和 3 求和：

```js
altSum3(1)(2)(3); // 6
```

> **提示**
>
> 继续往下读之前，不妨做个小测试：如果执行 `altSum3(1, 2, 3)`，会得到什么？提示：结果并非是个数字！完整答案参见下文。

该函数是怎么运作的呢？不妨将其拆分为多次调用，这也是上面那句表达式在 `JavaScript` 解释器上的计算方式：

```js
let fn1 = altSum3(1);
let fn2 = fn1(2);
let fn3 = fn2(3);
```

动用您的函数式思维！根据定义，调用 `altSum3(1)` 的结果，应该是一个函数。该函数利用了闭包，可以等效解析为如下形式：

```js
let fn1 = y => z => 1 + y + z;
```

这里的 `altSum3()` 函数接收的是单参数，而非三个参数；而其结果，`fn1`，也是一个接收单参数的函数。运行 `fn1(2)` 的结果同样是一个函数，同样也只接收一个参数，等效形式如下：

```js
let fn2 = z => 1 + 2 + z;
```

再运行 `fn2(3)`，得到最终结果。如前所述，函数执行的是相同的运算，但实现方式上有着天壤之别。

您可能觉得柯里化只是一个特殊的技巧：谁会只调用单参数的函数呢？后续在第八章《连接函数——管道与组合》以及第十二章《构筑更好的容器——函数式的数据类型》中考虑如何将函数连接在一起时，您将看到其中的原因，届时将多个参数从上一步传递到下一步的操作是不被允许的。



### 3.1.3. 将函数用作对象 Functions as objects

#### 1. `React-Redux` 中的 `reducer` A React-Redux reducer

#### 2. 不必要的错误 An unnecessary mistake

#### 3. 使用“方法” Working with methods

## 3.2. 以函数式编程的方式使用函数  Using functions in FP ways

### 3.2.1. 注入——整理出来 Injection – sorting it out

### 3.2.2. 回调、期约对象及延续 Callbacks, promises, and continuations

### 3.2.3. 延续传参风格 Continuation passing style

### 3.2.4. 腻子脚本 Polyfills

#### 1. 检测 `Ajax` Detecting Ajax

#### 2. 补缺函数 Adding missing functions

### 3.2.5. 插入处理 Stubbing

### 3.2.6. 立即调用 Immediate invocation

## 3.3. 小结

## 3.4. 思考题